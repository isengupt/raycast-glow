(this["webpackJsonpthree-template"]=this["webpackJsonpthree-template"]||[]).push([[0],{16:function(e,n,t){},17:function(e,n,t){"use strict";t.r(n);var i=t(1),a=t(3),s=t.n(a),o=t(8),r=t.n(o),c=(t(16),t(4)),l=t(9),m=t(2),h=t(6),u=t(5),v=t(0),d=t(10),f=function(e){Object(h.a)(t,e);var n=Object(u.a)(t);function t(e){var i;return Object(c.a)(this,t),(i=n.call(this,e)).setupResize=function(){window.addEventListener("resize",i.resize)},i.resize=function(){var e,n;i.width=i.container.offsetWidth,i.height=i.container.offsetHeight,i.renderer.setSize(i.width,i.height),i.camera.aspect=i.width/i.height,console.log("resize"),i.imageAspect=1,i.height/i.width>i.imageAspect?(e=i.width/i.height*i.imageAspect,n=1):(e=1,n=i.height/i.width/i.imageAspect),i.material.uniforms.resolution.value.x=i.width,i.material.uniforms.resolution.value.y=i.height,i.material.uniforms.resolution.value.z=e,i.material.uniforms.resolution.value.w=n;var t=i.camera.position.z;i.camera.fov=180/Math.PI*2*Math.atan(1/(2*t)),i.width/i.height>1?i.plane.scale.x=i.camera.aspect:i.plane.scale.y=1/i.camera.aspect,i.camera.updateProjectionMatrix(),console.log(i.camera)},i.start=i.start.bind(Object(m.a)(i)),i.stop=i.stop.bind(Object(m.a)(i)),i.animate=i.animate.bind(Object(m.a)(i)),i}return Object(l.a)(t,[{key:"componentDidMount",value:function(){this.scene=new v.h,this.renderer=new v.o,this.renderer.setClearColor("#000"),this.renderer.setSize(this.width,this.height),this.renderer.physicallyCorrectLights=!0,this.renderer.outputEncoding=v.p,this.container=document.getElementById("scene"),this.width=this.mount.clientWidth,this.height=this.mount.clientHeight,this.mount.appendChild(this.renderer.domElement),this.camera=new v.e(75,this.width/this.height,.1,1e3),this.camera.position.set(0,0,2),this.controls=new d.a(this.camera,this.renderer.domElement),this.time=0,this.setupResize(),this.addObjects(),this.animate(),this.resize(),this.mouseEvents()}},{key:"mouseEvents",value:function(){this.mouse=new v.l;var e=this;window.addEventListener("mousemove",(function(n){e.mouse.x=n.clientX/window.innerWidth*2-1,e.mouse.y=-n.clientY/window.innerHeight*2+1,e.material.uniforms.mouse.value=e.mouse}),!1)}},{key:"addObjects",value:function(){this.material=new v.i({extensions:{derivatives:"#extension GL_OES_standard_derivatives : enable"},side:v.a,uniforms:{time:{type:"f",value:0},mouse:{type:"v2",value:new v.l(0,0)},resolution:{type:"v4",value:new v.n},uvRate1:{value:new v.l(1,1)}},vertexShader:"\n\nuniform float time;\nvarying vec2 vUv;\nvarying vec3 vPosition;\nuniform sampler2D t; \n\nfloat PI = 3.141592653589793238;\n\nvoid main()\t{\n    vUv = uv;\n    vPosition = position;\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.);\n    gl_PointSize = 2.; \n    gl_Position = projectionMatrix * mvPosition;\n\n}\n",fragmentShader:"\n\nuniform float time;\nuniform float progress;\nuniform sampler2D texture1;\nuniform sampler2D texture2; \nuniform vec4 resolution;\nuniform vec2 mouse;\n\nvarying vec2 vUv;\nvarying vec3 vPosition;\nfloat PI = 3.141592653589793238;\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle) {\n\tmat4 m = rotationMatrix(axis, angle);\n\treturn (m * vec4(v, 1.0)).xyz;\n}\n\nfloat sphere(vec3 p ) {\n    return length(p) -0.5;\n}\n\nfloat sdBox(vec3 p , vec3 b) {\n    vec3 q = abs(p) - b; \n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat SineCrazy (vec3 p) {\n    return 1. - (cos(p.x) + cos(p.y) + cos(p.z))/3.;\n}\n\nfloat scene(vec3 p) {\n    vec3 p1 = rotate(p, vec3(1.,1.,1.),time/4.);\n    //return sdBox(p1, vec3(0.5,0.5,0.5));\nfloat scale = 15. + 10. * sin(time/12.);\n    return max(sphere(p1), (0.85 - SineCrazy(p1*scale))/scale);\n\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 o = vec2(0.001,0.);\n\n    return normalize(\n        vec3(\n            scene(p + o.xyy) - scene(p - o.xyy),\n            scene(p + o.yxy) - scene(p - o.yxy),\n            scene(p + o.yyx) - scene(p - o.yyx)\n        )\n    );\n}\n\nvec3 GetColor(float amount) {\n    vec3 col = 0.5 + 0.5 * cos(6.28319 * (vec3(0.2,0.0,0.0) + amount * vec3(1.0,1.0,0.5)));\n    return col * amount;\n}\n\nvec3 GetColorAmount(vec3 p) {\n    float amount = clamp((1.5 - length(p))/2.,0.,1.);\n    vec3 col = 0.5 + 0.5 * cos(6.28319 * (vec3(0.2,0.0,0.0) + amount * vec3(1.0,1.0,0.5)));\n    return col * amount;\n}\n\n\nvoid main()\t{\n    vec2 newUV = (vUv - vec2(0.5))*resolution.zw + vec2(0.5);\n\n\n    vec2 p = newUV - vec2(0.5);\n\n    p.x += mouse.x*0.1;\n    p.y += mouse.y*0.1;\n\n\n\n    //float bw = step(newUV.y, 0.6);\n\n    vec3 camPos = vec3(0.,0.,2. + 0.5*sin(time/4.));\n\n    vec3 ray = normalize(vec3(p, -1.));\n\n    vec3 rayPos = camPos;\n\n    float curDist = 0.;\n    float rayLen = 0.;\n\n    vec3 light = vec3(-1.,1.,1.);\n\n    vec3 color  = vec3(0.);\n\n    for (int i =0; i<=64;i++) {\n        curDist = scene(rayPos);\n\n        rayLen += 0.6*curDist;\n\n        rayPos = camPos + ray*rayLen;\n\n        if(abs(curDist)<0.001 ) {\n            vec3 n = getNormal(rayPos);\n\n            float diff = dot(n,light)\n;\n\n//color = GetColor(diff);\n//color = GetColor(2. * length(rayPos));\nbreak;\n        }\n\n        color += 0.04 * GetColorAmount(rayPos);\n\n\n    }\n\n\n\n\n    gl_FragColor = vec4(color,1.);\n    gl_FragColor.r -= abs(mouse.x) * 0.1;\n}\n"}),this.geometry=new v.f(1,1,1,1),this.plane=new v.d(this.geometry,this.material),this.scene.add(this.plane)}},{key:"componentWillUnmount",value:function(){this.stop(),this.mount.removeChild(this.renderer.domElement)}},{key:"start",value:function(){this.frameId||(this.frameId=requestAnimationFrame(this.animate))}},{key:"stop",value:function(){cancelAnimationFrame(this.frameId)}},{key:"animate",value:function(){this.time+=.05,this.material.uniforms.time.value=this.time,this.frameId=requestAnimationFrame(this.animate),this.renderScene()}},{key:"renderScene",value:function(){this.renderer.render(this.scene,this.camera)}},{key:"render",value:function(){var e=this;return Object(i.jsx)("div",{id:"scene",ref:function(n){e.mount=n}})}}]),t}(a.Component);var p=function(){return Object(i.jsxs)(i.Fragment,{children:[Object(i.jsxs)("div",{className:"frame",children:[Object(i.jsx)("h1",{className:"frame__title",children:"Shape Morphing Demo"}),Object(i.jsx)("div",{className:"frame__links"}),Object(i.jsxs)("div",{className:"frame__nav",children:[Object(i.jsx)("a",{className:"frame__link",href:"https://isengupt.github.io/outward-lines/",children:"Previous"}),Object(i.jsx)("a",{className:"frame__link",href:"#",children:"Resume"}),Object(i.jsx)("a",{className:"frame__link",href:"https://github.com/isengupt/raycast-glow/",children:"GitHub"})]})]}),Object(i.jsx)(f,{})]})};r.a.render(Object(i.jsx)(s.a.StrictMode,{children:Object(i.jsx)(p,{})}),document.getElementById("root"))}},[[17,1,2]]]);
//# sourceMappingURL=main.90cfe400.chunk.js.map